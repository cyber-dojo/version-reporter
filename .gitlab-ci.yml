image: registry.gitlab.com/cyber-dojo/version-reporter:v1
stages:
  - .pre
  - build
  - test
  - sdlc
  - deployment

variables:
  KOSLI_DRY_RUN: "False"
  KOSLI_ORG: cyber-dojo
  KOSLI_FLOW: version-reporter
  DOCKER_TLS_CERTDIR: "/certs"

create-kosli-flow:
  stage: .pre
  script:
    - kosli create flow $KOSLI_FLOW
        --description="UX for git+image version-reporter"
        --template=artifact,branch-coverage,security-scan,pull-request
#        --template=artifact,branch-coverage,security-scan,pull-request,manual-approval

build-job:
  stage: build
  needs: [ "create-kosli-flow" ]
  services: [ "docker:24.0.5-dind" ]
  artifacts:
    paths: [ output/ ]
  script:
    - source ./sh/echo_versioner_env_vars.sh
    - export $(echo_versioner_env_vars)
    - docker-compose build --build-arg COMMIT_SHA=$CI_COMMIT_SHA
    - TAGGED_IMAGE=cyberdojo/version-reporter:${CI_COMMIT_SHA:0:7}
    - echo "${DOCKER_PASS}" | docker login --username "${DOCKER_USER}" --password-stdin
    - docker push $TAGGED_IMAGE
    - kosli report artifact $TAGGED_IMAGE --artifact-type=docker
    - FINGERPRINT=$(kosli fingerprint $TAGGED_IMAGE --artifact-type=docker)
    - mkdir output
    - echo $FINGERPRINT  > output/fingerprint
    - echo $TAGGED_IMAGE > output/tagged_image

branch-coverage-job:
  stage: test
  needs: [ "build-job" ]
  services: [ "docker:24.0.5-dind" ]
  artifacts:
    paths: [ output/ ]
  script:
    - source ./sh/run_tests_with_coverage.sh
    - if run_tests_with_coverage; then KOSLI_COMPLIANT=true; else KOSLI_COMPLIANT=false; fi
    - kosli report evidence artifact generic $(cat output/tagged_image)
          --fingerprint=$(cat output/fingerprint)
          --compliant=$KOSLI_COMPLIANT
          --description="server & client branch-coverage reports"
          --name=branch-coverage
          --user-data=./test/evidence.json

security-scan-job:
  image: registry.gitlab.com/cyber-dojo/version-reporter:v1-ubuntu
  stage: test
  needs: [ "build-job" ]
  artifacts:
    paths: [ output/ ]
  script:
    - set +e
    - snyk --version
 #    - snyk container test $(cat output/tagged_image)
 #        --file=Dockerfile
 #        --json-file-output=snyk.json
 #        --policy-path=.snyk
 #    - kosli report evidence artifact snyk $(cat output/tagged_image)
 #        --fingerprint=$(cat output/fingerprint)
 #        --name=security-scan
 #        --scan-results=snyk.json

pull-request-job:
 stage: test
 needs: [ "build-job" ]
 artifacts:
   paths: [ output/ ]
 script:
   - kosli report evidence artifact pullrequest gitlab $(cat output/tagged_image)
       --fingerprint=$(cat output/fingerprint)
       --name=pull-request
       --gitlab-token=$KOSLI_GITLAB_TOKEN

sdlc-gate-job:
  stage: sdlc
  needs:
    - branch-coverage-job
    - security-scan-job
    - pull-request-job
  artifacts:
    paths: [ output/ ]
  script:
    - kosli assert artifact $(cat output/tagged_image)
        --fingerprint=$(cat output/fingerprint)

beta-deployment-job:
  needs: [ "sdlc-gate-job" ]
  stage: deployment
  artifacts:
    paths: [ output/ ]
  variables:
    AWS_ACCESS_KEY_ID: ${AWS_ACCESS_KEY_ID_BETA}
    AWS_SECRET_ACCESS_KEY: ${AWS_SECRET_ACCESS_KEY_BETA}
  script:
    - kosli expect deployment $(cat output/tagged_image)
        --fingerprint=$(cat output/fingerprint)
        --description "Deployed to aws-beta in Gitlab pipeline"
        --environment aws-beta
    - export TF_VAR_TAGGED_IMAGE=$(cat output/tagged_image)
    - cd deployment/terraform && tf.sh apply

 #prod-deployment-job:
 #  needs: [ "beta-deployment-job" ]
 #  stage: deployment
 #  artifacts:
 #    paths: [ output/ ]
 #  variables:
 #    AWS_ACCESS_KEY_ID: ${AWS_ACCESS_KEY_ID_PROD}
 #    AWS_SECRET_ACCESS_KEY: ${AWS_SECRET_ACCESS_KEY_PROD}
 #  script:
 #    - kosli expect deployment $(cat output/tagged_image)
 #        --fingerprint=$(cat output/fingerprint)
 #        --description "Deployed to aws-prod in Gitlab pipeline"
 #        --environment aws-prod
 #    - DEPLOY_TO_AWS_PROD
