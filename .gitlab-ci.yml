image: registry.gitlab.com/cyber-dojo/version-reporter:v1

.only-main:
  only:
    - main

stages:
  - kosli-trail
  - build-image
  - test-image
  - sdlc-gate
  - beta
  - approval
  - production

variables:
  KOSLI_DRY_RUN: "False"
  KOSLI_ORG: cyber-dojo
  KOSLI_FLOW: version-reporter
  DOCKER_TLS_CERTDIR: "/certs"

start-kosli-trail:
  extends: [ .only-main ]
  stage: kosli-trail
  script:
    - kosli create flow $KOSLI_FLOW
        --description="UX for git+image version-reporter"
        --template=artifact
        # --template=artifact,branch-coverage,security-scan,pull-request

# Build and push the image to the Dockerhub and ECR (both beta and prod repositories)
build:
  extends: [ .only-main ]
  stage: build-image
  needs: [ "start-kosli-trail" ]
  services: [ "docker:24.0.5-dind" ]
  artifacts:
    paths: [ output/ ]
  script:
    - source ./sh/echo_versioner_env_vars.sh
    - export $(echo_versioner_env_vars)
    - docker-compose build --build-arg COMMIT_SHA=$CI_COMMIT_SHA
    - TAGGED_IMAGE=cyberdojo/version-reporter:${CI_COMMIT_SHA:0:7}
    - echo "${DOCKER_PASS}" | docker login --username "${DOCKER_USER}" --password-stdin
    - docker push $TAGGED_IMAGE
    - kosli report artifact $TAGGED_IMAGE --artifact-type=docker
    - FINGERPRINT=$(kosli fingerprint $TAGGED_IMAGE --artifact-type=docker)
    - export AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID_BETA} && export AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY_BETA}
    - export ECR_REPO_BETA=244531986313.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com/version-reporter
    - docker tag $TAGGED_IMAGE ${ECR_REPO_BETA}:${CI_COMMIT_SHA:0:7}
    - aws ecr get-login-password --region ${AWS_DEFAULT_REGION} | docker login --username AWS --password-stdin ${ECR_REPO_BETA}
    - docker push ${ECR_REPO_BETA}:${CI_COMMIT_SHA:0:7}
    - export AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID_PROD} && export AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY_PROD}
    - export ECR_REPO_PROD=274425519734.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com/version-reporter
    - docker tag $TAGGED_IMAGE ${ECR_REPO_PROD}:${CI_COMMIT_SHA:0:7}
    - aws ecr get-login-password --region ${AWS_DEFAULT_REGION} | docker login --username AWS --password-stdin ${ECR_REPO_PROD}
    - docker push ${ECR_REPO_PROD}:${CI_COMMIT_SHA:0:7}
    - mkdir output
    - echo $FINGERPRINT  > output/fingerprint
    - echo $TAGGED_IMAGE > output/tagged_image
    - echo ${ECR_REPO_BETA}:${CI_COMMIT_SHA:0:7} > output/tagged_image_ecr_beta
    - echo ${ECR_REPO_PROD}:${CI_COMMIT_SHA:0:7} > output/tagged_image_ecr_prod

branch-coverage:
  extends: [ .only-main ]
  stage: test-image
  needs: [ "build" ]
  services: [ "docker:24.0.5-dind" ]
  artifacts:
    paths: [ output/ ]
  script:
    - source ./sh/run_tests_with_coverage.sh
    # - if run_tests_with_coverage; then KOSLI_COMPLIANT=true; else KOSLI_COMPLIANT=false; fi
    # - kosli report evidence artifact generic $(cat output/tagged_image)
    #     --fingerprint=$(cat output/fingerprint)
    #     --compliant=$KOSLI_COMPLIANT
    #     --description="server & client branch-coverage reports"
    #     --name=branch-coverage
    #     --user-data=./test/evidence.json

security-scan:
  extends: [ .only-main ]
  image: registry.gitlab.com/cyber-dojo/version-reporter:v1-ubuntu
  stage: test-image
  needs: [ "build" ]
  artifacts:
    paths: [ output/ ]
  script:
    - set +e
    # - snyk container test $(cat output/tagged_image)
    #     --file=Dockerfile
    #     --json-file-output=snyk.json
    #     --policy-path=.snyk
    # - kosli report evidence artifact snyk $(cat output/tagged_image)
    #     --fingerprint=$(cat output/fingerprint)
    #     --name=security-scan
    #     --scan-results=snyk.json

pull-request:
  extends: [ .only-main ]
  stage: test-image
  needs: [ "build" ]
  artifacts:
    paths: [ output/ ]
  script:
    - pwd
    # - kosli report evidence artifact pullrequest gitlab $(cat output/tagged_image)
    #     --fingerprint=$(cat output/fingerprint)
    #     --name=pull-request
    #     --gitlab-token=$KOSLI_GITLAB_TOKEN

sdlc-gate:
  extends: [ .only-main ]
  stage: sdlc-gate
  needs:
    - branch-coverage
    - security-scan
    - pull-request
  artifacts:
    paths: [ output/ ]
  script:
    - kosli assert artifact $(cat output/tagged_image)
        --fingerprint=$(cat output/fingerprint)

beta-deployment:
  extends: [ .only-main ]
  needs: [ "sdlc-gate" ]
  stage: beta
  artifacts:
    paths: [ output/ ]
  variables:
    AWS_ACCESS_KEY_ID: ${AWS_ACCESS_KEY_ID_BETA}
    AWS_SECRET_ACCESS_KEY: ${AWS_SECRET_ACCESS_KEY_BETA}
    KOSLI_ENVIRONMENT_NAME: aws-beta
  script:
    - kosli expect deployment $(cat output/tagged_image)
        --fingerprint=$(cat output/fingerprint)
        --description "Deployed to ${KOSLI_ENVIRONMENT_NAME} in Gitlab pipeline"
        --environment ${KOSLI_ENVIRONMENT_NAME}
    - export TF_VAR_TAGGED_IMAGE=$(cat output/tagged_image_ecr_beta)
    - cd deployment/terraform && tf.sh apply

approval:
  # variables:
  #   GIT_DEPTH: 1  # clone full history
  # variables:
  #   GIT_STRATEGY: clone
  extends: [ .only-main ]
  needs: [ "beta-deployment" ]
  stage: approval
  artifacts:
    paths: [ output/ ]
  when: manual
  allow_failure: false
  script:
    - git fetch origin production
    - git branch -a
    - git rev-parse origin/production
    - git rev-list origin/production..HEAD
    - kosli report approval $(cat output/tagged_image)
        --fingerprint=$(cat output/fingerprint)
        --description="Approved in Gitlab pipeline"
        --oldest-commit=origin/production
        --debug

prod-deployment:
  extends: [ .only-main ]
  needs: [ "approval" ]
  stage: production
  artifacts:
    paths: [ output/ ]
  variables:
    AWS_ACCESS_KEY_ID: ${AWS_ACCESS_KEY_ID_PROD}
    AWS_SECRET_ACCESS_KEY: ${AWS_SECRET_ACCESS_KEY_PROD}
    KOSLI_ENVIRONMENT_NAME: aws-prod
  script:
    - kosli expect deployment $(cat output/tagged_image)
        --fingerprint=$(cat output/fingerprint)
        --description "Deployed to ${KOSLI_ENVIRONMENT_NAME} in Gitlab pipeline"
        --environment ${KOSLI_ENVIRONMENT_NAME}
    - export TF_VAR_TAGGED_IMAGE=$(cat output/tagged_image_ecr_prod)
    - cd deployment/terraform && tf.sh apply

update-git-tracking-branch:
  extends: [ .only-main ]
  needs: [ "prod-deployment" ]
  stage: production
  script:
    - git log --graph --full-history --all --color --date=short --pretty=format:"%Cred%x09%h %Creset%ad%Cblue%d %Creset %s %C(bold)(%an)%Creset" | head -n 30
    - git checkout --track origin/production
    - git merge --ff-only ${CI_COMMIT_SHA}
    - git push origin production

#push-latest-image-to-public-registry:
#  extends: [ .only-main ]
#  needs: [ "update-git-tracking-branch" ]
#  services: [ "docker:24.0.5-dind" ]
#  stage: deploy-image
#  artifacts:
#    paths: [ output/ ]
#  script:
#    - docker pull $(cat output/tagged_image)
#    - docker tag $(cat output/tagged_image) cyberdojo/version-reporter:latest
#    - echo "${DOCKER_PASS}" | docker login --username "${DOCKER_USER}" --password-stdin
#    - docker push cyberdojo/version-reporter:latest